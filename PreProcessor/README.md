# Stappp 前处理 技术说明文档

## 前处理任务简述

*Stappp* 的前处理任务主要是对在**Abaqus** 中建模的桥梁模型所产生的_inp_ 文件进行适当的处理，产生符合*stappp* 程序的读入要求的输入文件。

## *Abaqus* 建模*inp* 文件特点介绍和处理方法

### *Abaqus* *inp* 文件详解

 

```python
*Heading
** Job name: Job-1 Model name: Model-1
** Generated by: Abaqus/CAE 6.14-1
*Preprint, echo=NO, model=NO, history=NO, contact=NO
**  
```

Inp文件总是以*Heading* 开头，接下来是用一行或者多行描述模型的标题和相关信息。

*Reprint* 可设置在(*.dat*)文件中记录的内容，上述为默认的记录方式。

```python
** PARTS
**
*Part, name=Part-Cable50
*Node
      1,          50.,           0.,           0.
      2,           0.,         150.,           0.
*Element, type=T3D2
1, 1, 2
*Nset, nset=_PickedSet2, internal
 1, 2
*Elset, elset=_PickedSet2, internal
 1,
** Section: Section-Cable
*Solid Section, elset=_PickedSet2, material=Steel
0.25,
*End Part
**  
```

定义一个Part的标准格式，**part,name=* 部件名称

我们的这个文件中所采用的是非独立实体，要在下面的数据块中定义详细的节点，单元，截面属性

**Mesh在Part上面** 

另外对于独立的实体，Part数据块没有实际性的数据，如节点、单元和截面属性等内容在*instance* 数据块中定义，而此时的Mesh也是在Instance数据块上定义

节点的定义以**Node* 开始

基本的定义方法：

​	节点标号，节点坐标1，节点坐标2，节点坐标3

单元的定义： **Element,type=* 单元类型

​	单元编号：节点1编号，节点2编号，节点3编号，... 

然后就定义集合，集合的种类有两种，节点的集合*Nset* 和单元的集合 *Eset* ，而这种集合也分为两种：

+ 第一种是这里定义在Part或者Instance中的集合，一般会接在截面属性前，用于定义截面属性
+ 第二种是在Assembly模块中，后面将讲到

下面就是定义模型的界面属性

```python
** ASSEMBLY
**
*Assembly, name=Assembly
**  
*Instance, name=Part-Floor-1, part=Part-Floor
*End Instance
**  
*Instance, name=Part-Pier-2, part=Part-Pier
          0.,         -10.,        83.75
          0.,         -10.,        83.75,           1.,         -10.,        83.75,          90.
*End Instance
```

这里定义Part的组装模块，定义不同的Instance组装为整个模型

这里的参数是对于part的空间平移和旋转操作

```python
**  
*Nset, nset=Set-102, instance=Part-Pier-2
   1,   2,   3,   4,   9,  10,  13,  14,  15,  16,  17,  18, 181, 182, 183, 184
 185, 269, 270, 507, 508
```

这里就是对Instance内的点做点集，主要是为了定义后来的约束

```python
*Surface, type=NODE, name=m_Set-6_CNS_, internal
m_Set-6, 1.
```

对于Surface的定义也是类似

```python
** Constraint: Constraint-2
*Tie, name=Constraint-2, adjust=yes, no rotation
s_Set-6_CNS_, m_Set-6_CNS_
```

这里通过约束给出Tie，定义了点集之间的关系，这里相当于定义说这些Element的点是连接在一起的。

```python
** MATERIALS
** 
** For the SupportBeam
*Material, name=Aluminum
*Density
2710.,
*Elastic
 7e+10, 0.346
```

对材料的数据块定义

首先给出材料给哪一个部件定义

然后给出 密度，弹性模量，泊松比

```python
** STEP: Step-1
** 
*Step, name=Step-1, nlgeom=NO
*Static
1., 1., 1e-05, 1.
** 
```

加载步的定义;

分别是：分析时间，最小增量步，最大增量步

```python 
** BOUNDARY CONDITIONS
** 
** Name: BC-1 Type: Displacement/Rotation
*Boundary
Set-102, 1, 1
Set-102, 2, 2
Set-102, 3, 3
** 
```

边界条件：给出定义的点的集合 和 定义的类型

这里是固定 Set-102 的三个方向的位移和转角自由度

```python
** LOADS
** 
** Name: Load-1   Type: Gravity
*Dload
, GRAV, 10., 0., 0., -1.
** 
```

__*Dload __ 是定义在单元上的分布载荷

（集中载荷通过 *Cload 面上的分布载荷用 *DSload 定义）

```python
** OUTPUT REQUESTS
** 
*Restart, write, frequency=0
** 
** FIELD OUTPUT: F-Output-1
** 
*Output, field, variable=PRESELECT
** 
** HISTORY OUTPUT: H-Output-1
** 
*Output, history, variable=PRESELECT
*End Step

```

将场变量和历史变量写入ODB文件

参考：**Abaqus 6.14 Documention** <http://wufengyun.com:888/>

## 前处理处理思路和核心方法



### 核心思路

主要的核心的注意点有以下：

+ 需要区分独立网格和非独立网格的不同的功能和特点
+ 需要对节点的编号进行从局部编号到全局编号的转变
+ 需要研究不同的单元之间的连接关系
+ 需要研究固定边界条件等的给定方法
+ 需要对*inp* 文件的格式和特点熟悉

### 核心方法

**步骤**

1. Mesh on parts - Mesh on instances
2. Merge nodes
3. File Read and Process(renumber nodes)

其中前两步的Python代码如下：

```python
mdb.models['Job-1'].setValues(noPartsInputFile=ON)
```

```python 
mbd.models['Job-1'].rootAssembly.InstanceFromBooleanMerge(name='PartMerge',instances=('Part-1','Part-2','Part-3'),domain=MESH,mergeNodes=ALL)
```

分别生成*Merge-1* *Merge-11* 文件，给第三步的程序读取生成Input文件

第三步*Preprocessor.py* 实现：

对*Inp* 文件中的各个关键词用定位：

```python
-----------读取特征关键词位置-------
#关键词位置信息
keylocation = [0 for x in range(line_len)] 
#注意，keylocation中为所有行的关键词种类的定义信息，最后的关键词位置信息会存储在keyloc中
pos_endallinstance = 0
for i in range(0,line_len-1):
    if line[i].find('*Part')!=-1:           
        keylocation[i] = 1
    if line[i].find('*Node')!=-1:           
        keylocation[i] = 2
    if line[i].find('*Element')!=-1:        
        keylocation[i] = 3
    if line[i].find('*Material')!=-1:
        keylocation[i] = 5
    if line[i].find('*Boundary')!=-1:
        keylocation[i] = 6
    if line[i].find('*Instance')!=-1:
        keylocation[i] = 7
    if line[i].find('*End Instance')!=-1:
        keylocation[i] = 8
        pos_endallinstance = i
    #if line[i].find('*Nset')!=-1:       #注意只从 最后一个instance后定义的nset开始计数 需要调整
     #   keylocation[i] = 9              #需要仿照Element的方式计算出nest的结束位置
    if line[i].find('*Tie')!=-1:        #*Tie只有两行：标题和Tie的nset所以只需要记录其开始位置
        keylocation[i] = 11

for i in range(pos_endallinstance,line_len-1):       # pos_endallinstance给出instance结束的位置也给出了
    if line[i].find('*Nset')!=-1:                   # 我们需要开始记录的nset的位置
        keylocation[i] = 9 

j = 0
for i in range(0,line_len-1):
    if keylocation[i] == 3:
        j = 1
        continue
    if j == 1:
        if line[i+1][:1] == '*':
            keylocation[i] = 4            #每个element结束位置--4
            j = 0

j = 0
for i in range(0,line_len-1):
    if keylocation[i] == 9:
        j = 1
        continue
    if j == 1:
        if line[i+1][:1] == '*':
            keylocation[i] = 10            #每个nset结束位置--10
            j = 0
       
keynum = max(keylocation)    
keyloc = [[] for x in range(keynum)]          
for i in range(0,line_len-1):
    for j in range(0,keynum):
        if keylocation[i] == (j+1):
            keyloc[j].append(i)
            
partnum = len(keyloc[0])     #PART个数

#print('keyloc',keyloc)

# keyloc[0]:Part  keyloc[1]:Node keyloc[2]:Element keyloc[3]:Element结束位置
# keyloc[4]:Material keyloc[5]:Boundary  keyloc[6]:Instance  keyloc[7]:Instance结束
# keyloc[8]:Nset   keyloc[9]:Tie        

```

然后读取各个部分的信息：

+ 固定边界

```python
#-----------读取固定边界信息-------------
def readboundary(b_set):
    i = 0
    j = 0
    boundary = []   
    for i in range(line_len):
        if line[i].find('*Nset, nset='+b_set)!=-1:
            j = 1
            continue
        if j==1:
            temp = line[i]
            while temp.find(',')!=-1:
                boundary.append(int(temp[:temp.find(',')]))
                temp = temp[temp.find(',')+1:]
            boundary.append(int(temp))
            if line[i+1].find('*')!=-1:
                j = 0
    return boundary

# keyloc[5]中存储的就是bounary的信息读取出边界的nset 再去读取节点号
boundary = []
b_line = line[keyloc[5][0]+1]
b_set = b_line[:b_line.find(',')]
boundary=readboundary(b_set)
#print('boundary',boundary)    
```

+ 各个部分的信息

```python
#-----------读取NODE信息-------------
def readnode(beg,end):
    
#-----------读取ELEMENT信息-------------
def readelement(beg,end):
  
#-----------读取PART名称-------------
def readpartname(beg):
 
#-----------读取ELEMENT名称----------
def readelementname(beg):
 
#-----------读取MATERIAL信息----------
def readmaterial(beg):
```

+ 由于8H单元有两种材料属性的节点，需要找到分界点

```python 
C3D8_pier = 0
for i in range(line_len):
    if line_i[i].find('** PART INSTANCE: PART-PIER-1')!=-1: 
        j = 1
        continue
    if j==1 and line_i[i].find('*Nset')!=-1:
        C3D8_pier = int(line_i[i-1][:line_i[i-1].find(',')])
        break
```

+ 需要修改ID矩阵，并扩展到6维

```python
#-----------输出ID信息 扩充ID到6维-------------
#考虑固定边界和不同单元的自由度限制
ID_ = [[1,1,0,0,0,1],[0,1,0,1,0,1]]
# ID_[0]对应壳单元有五个自由度 所以将node_b[3],node_b[4]设置为0  对应ID_[0,0,1]
#需要用的是3,4,5 对于板单元而言 所以ID_ [1,1,0,0,0,1] 
#而如果是板单元有三个自由度也无所谓
# ID_[2]对应梁单元 自由度有6 所以将node[]均设置为0 对应ID_ [0,0,0]
#其实只需要对梁单元和板单元的自由度的ID矩阵做一个调整
#print('element[i][1][0]',element[i][0])
for i in range(len(keyloc[2])):
        for j in range(len(element[i][1][0])):
            e_num = element[i][1][0][j]   #单个单元的序号
            e_node = element[i][1][1][j]  #单个单元的节点的全局坐标
            for s in range(len(material_e)):
                if material_e[s][2][0] <= e_num <= material_e[s][2][1]:
                    for k in e_node:
                        if node_b[k-1][0]==0:      #没有在固定边界上
                            if s==0:
                                node_b[k-1]=ID_[0] # 板单元
                            elif s==2:
                                node_b[k-1]=ID_[1] #梁单元
                        #else:        
                        #for p in range(3):
                        #    node_b[k-1][p+3]=node_b[k-1][p+3]*ID_[s][p]
```

